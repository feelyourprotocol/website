import{_ as i,c as a,o as s,ak as r}from"./chunks/framework.DyoGesZS.js";const c=JSON.parse('{"title":"Library Forks","description":"","frontmatter":{},"headers":[],"relativePath":"guide/library-forks.md","filePath":"guide/library-forks.md"}'),n={name:"guide/library-forks.md"};function t(l,e,o,h,p,k){return s(),a("div",null,[...e[0]||(e[0]=[r(`<h1 id="library-forks" tabindex="-1">Library Forks <a class="header-anchor" href="#library-forks" aria-label="Permalink to â€œLibrary Forksâ€">â€‹</a></h1><div class="warning custom-block"><p class="custom-block-title">ðŸš§ Under Active Development</p><p>Both the Feel Your Protocol project and this documentation are in an early stage and under active development. Things may change frequently.</p></div><h2 id="why-forks" tabindex="-1">Why Forks? <a class="header-anchor" href="#why-forks" aria-label="Permalink to â€œWhy Forks?â€">â€‹</a></h2><p>Feel Your Protocol runs real Ethereum library code in the browser. Some EIP widgets need a modified version of an existing library â€” for example, a version with a new precompile implementation, or experimental gas calculation changes that haven&#39;t been released yet.</p><p>Rather than waiting for upstream releases, we maintain targeted forks that are used by specific EIP pages.</p><h2 id="how-forks-work" tabindex="-1">How Forks Work <a class="header-anchor" href="#how-forks-work" aria-label="Permalink to â€œHow Forks Workâ€">â€‹</a></h2><h3 id="npm-package-aliases" tabindex="-1">npm Package Aliases <a class="header-anchor" href="#npm-package-aliases" aria-label="Permalink to â€œnpm Package Aliasesâ€">â€‹</a></h3><p>Multiple versions of the same library coexist in <code>package.json</code> using npm aliases:</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;dependencies&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;@ethereumjs/evm&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^10.1.1-nightly.1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;@ethereumjs/evm-experimental&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;npm:@ethereumjs/evm@^11.0.0-fork.1&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Each alias is a fully independent install. In code, you import the specific version you need:</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { EVM } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@ethereumjs/evm&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                    // standard</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { EVM </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EVMExp } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@ethereumjs/evm-experimental&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // fork</span></span></code></pre></div><h3 id="monorepo-libraries" tabindex="-1">Monorepo Libraries <a class="header-anchor" href="#monorepo-libraries" aria-label="Permalink to â€œMonorepo Librariesâ€">â€‹</a></h3><p>For libraries from monorepos (like EthereumJS), where the target package has several intra-monorepo dependencies, we use <strong>pre-bundled ESM builds</strong>. The fork is bundled on the monorepo side with all internal dependencies resolved, producing a single ESM file with no internal wiring issues.</p><h3 id="per-route-isolation" tabindex="-1">Per-Route Isolation <a class="header-anchor" href="#per-route-isolation" aria-label="Permalink to â€œPer-Route Isolationâ€">â€‹</a></h3><p>Each fork is only imported in its specific EIP component. Thanks to Vite&#39;s code splitting, the fork&#39;s code is only loaded when the user visits that EIP&#39;s page. Other pages are unaffected.</p><h2 id="adding-a-new-fork" tabindex="-1">Adding a New Fork <a class="header-anchor" href="#adding-a-new-fork" aria-label="Permalink to â€œAdding a New Forkâ€">â€‹</a></h2><ol><li>Fork the upstream library (or create a branch if you have access)</li><li>Make your changes</li><li>For single-package repos: add an npm alias pointing to your fork&#39;s git URL</li><li>For monorepo packages: create a bundled build, then reference it</li><li>Import the fork only in your EIP&#39;s component file</li><li>Document the fork in this page</li></ol>`,17)])])}const g=i(n,[["render",t]]);export{c as __pageData,g as default};
